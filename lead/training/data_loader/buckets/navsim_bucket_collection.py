import os
from enum import IntEnum

import numpy as np
from tqdm import tqdm

from lead.common.constants import WeatherVisibility
from lead.training.config_training import TrainingConfig
from lead.training.data_loader.buckets.abstract_bucket_collection import AbstractBucketCollection
from lead.training.data_loader.buckets.bucket import Bucket


class NavsimPretrainSim2RealBuckets(IntEnum):
    BAD_WEATHER = 0

    # --- Scenario specific mining ---
    ACCIDENT_SCENARIO = 1
    ACCIDENT_TWO_WAYS_SCENARIO = 2
    BLOCKED_INTERSECTION_SCENARIO = 3
    CONSTRUCTION_OBSTACLE_SCENARIO = 4
    CONSTRUCTION_OBSTACLE_TWO_WAYS_SCENARIO = 5
    CROSSING_BICYCLE_FLOW_SCENARIO = 6
    CROSS_JUNCTION_DEFECT_TRAFFIC_LIGHT_SCENARIO = 7
    DYNAMIC_OBJECT_CROSSING_SCENARIO = 8
    ENTER_ACTOR_FLOW_SCENARIO = 9
    ENTER_ACTOR_FLOW_V2_SCENARIO = 10
    HARD_BREAK_ROUTE_SCENARIO = 11
    HAZARD_AT_SIDE_LANE_SCENARIO = 12
    HAZARD_AT_SIDE_LANE_TWO_WAYS_SCENARIO = 13
    HIGHWAY_CUT_IN_SCENARIO = 14
    HIGHWAY_EXIT_SCENARIO = 15
    INTERURBAN_ACTOR_FLOW_SCENARIO = 16
    INTERURBAN_ADVANCED_ACTOR_FLOW_SCENARIO = 17
    INVADING_TURN_SCENARIO = 18
    MERGER_INTO_SLOW_TRAFFIC_SCENARIO = 19
    MERGER_INTO_SLOW_TRAFFIC_V2_SCENARIO = 20
    NON_SIGNALIZED_JUNCTION_LEFT_TURN_SCENARIO = 21
    NON_SIGNALIZED_JUNCTION_LEFT_TURN_ENTER_FLOW_SCENARIO = 22
    NON_SIGNALIZED_JUNCTION_RIGHT_TURN_SCENARIO = 23
    OPPOSITE_VEHICLE_RUNNING_RED_LIGHT_SCENARIO = 24
    OPPOSITE_VEHICLE_TAKING_PRIORITY_SCENARIO = 25
    PARKED_OBSTACLE_SCENARIO = 26
    PARKED_OBSTACLE_TWO_WAYS_SCENARIO = 27
    PARKING_CROSSING_PEDESTRIAN_SCENARIO = 28
    PARKING_CUT_IN_SCENARIO = 29
    PARKING_EXIT_SCENARIO = 30
    PEDESTRIAN_CROSSING_SCENARIO = 31
    PRIORITY_AT_JUNCTION_SCENARIO = 32
    RED_LIGHT_WITHOUT_LEAD_VEHICLE_SCENARIO = 33
    SIGNALIZED_JUNCTION_LEFT_TURN_SCENARIO = 34
    SIGNALIZED_JUNCTION_LEFT_TURN_ENTER_FLOW_SCENARIO = 35
    SIGNALIZED_JUNCTION_RIGHT_TURN_SCENARIO = 36
    STATIC_CUT_IN_SCENARIO = 37
    VEHICLE_OPENS_DOOR_TWO_WAYS_SCENARIO = 38
    VEHICLE_TURNING_ROUTE_SCENARIO = 39
    VEHICLE_TURNING_ROUTE_PEDESTRIAN_SCENARIO = 40
    FAR_TARGET_POINT = 41

    # --- General mining ---
    TOWN15 = 42
    CURRENT_TARGET_POINT_BEHIND_EGO = 43
    OCCLUDED_JUNCTION = 44
    ENTERING_JUNCTION = 45
    CLOSE_TO_JUNCTION = 46
    RED_OVERHEAD_TRAFFIC_LIGHT = 47
    NEAR_URGENT_LANE_CHANGE = 48
    STOP_SIGN_HAZARD = 49
    LARGE_LATERAL_DEVIATION = 50
    VEHICLE_HAZARD = 51
    RED_EUROPE_TRAFFIC_LIGHT = 52
    RED_TRAFFIC_LIGHT = 53
    HIGH_ACCELERATION = 54
    MEDIUM_ACCELERATION = 55
    LOW_ACCELERATION = 56
    HIGH_ROUTE_CURVATURE = 57
    MEDIUM_ROUTE_CURVATURE = 58

    OTHERS = 59

    @classmethod
    def __len__(cls):
        return len(cls.__members__)

    @classmethod
    def index_of(cls, member):
        return list(cls).index(member)

    @classmethod
    def member_at(cls, index):
        return list(cls)[index]


class NavSimBucketCollection(AbstractBucketCollection):
    def __init__(self, root: str | list[str], config: TrainingConfig):
        self.buckets = [Bucket(config) for _ in range(len(NavsimPretrainSim2RealBuckets))]
        super().__init__(root, config)
        print(f"Using NavSim buckets with {len(NavsimPretrainSim2RealBuckets)} buckets")

    def _build_buckets(self):
        from lead.training.data_loader.carla_dataset import CARLAData

        carla_data = CARLAData(
            root=self.root, config=self.config, training_session_cache=None, random=False, build_buckets=True
        )
        self.trainable_routes = carla_data.bucket_collection.trainable_routes
        self.trainable_frames = carla_data.bucket_collection.trainable_frames
        self.total_routes = carla_data.bucket_collection.total_routes
        for sample_idx, sample in tqdm(enumerate(carla_data)):
            if sample_idx % 100000 == 0:
                self.print_statistic()
            route_dir = sample["route_dir"]
            frame_number = int(sample["frame_number"])

            if sample["visual_visibility"] > WeatherVisibility.CLEAR:
                self.buckets[NavsimPretrainSim2RealBuckets.BAD_WEATHER].add(route_dir, frame_number)
            # Scenario-specific mining
            elif sample["scenario_type"] == "Accident" and self._check_accident_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.ACCIDENT_SCENARIO].add(route_dir, frame_number)
            elif sample["scenario_type"] == "AccidentTwoWays" and self._check_accident_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.ACCIDENT_TWO_WAYS_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "BlockedIntersection" and self._check_blocked_intersection(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.BLOCKED_INTERSECTION_SCENARIO].add(route_dir, frame_number)
            elif sample["scenario_type"] == "ConstructionObstacle" and self._check_construction_obstacle_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.CONSTRUCTION_OBSTACLE_SCENARIO].add(route_dir, frame_number)
            elif sample["scenario_type"] == "ConstructionObstacleTwoWays" and self._check_construction_obstacle_scenario(
                sample
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.CONSTRUCTION_OBSTACLE_TWO_WAYS_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "CrossingBicycleFlow" and self._check_scenario_actor_close(
                sample, max_distance=10.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.CROSSING_BICYCLE_FLOW_SCENARIO].add(route_dir, frame_number)
            elif sample[
                "current_active_scenario_type"
            ] == "CrossJunctionDefectTrafficLight" and self._check_scenario_actor_close(sample, max_distance=10.0):
                self.buckets[NavsimPretrainSim2RealBuckets.CROSS_JUNCTION_DEFECT_TRAFFIC_LIGHT_SCENARIO].add(
                    route_dir, frame_number
                )
            elif sample["current_active_scenario_type"] == "DynamicObjectCrossing" and self._check_scenario_actor_close(
                sample, max_distance=20.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.DYNAMIC_OBJECT_CROSSING_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "EnterActorFlow" and bool(sample["near_urgent_lane_change"]):
                self.buckets[NavsimPretrainSim2RealBuckets.ENTER_ACTOR_FLOW_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "EnterActorFlowV2" and bool(sample["near_urgent_lane_change"]):
                self.buckets[NavsimPretrainSim2RealBuckets.ENTER_ACTOR_FLOW_V2_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "HardBreakRoute" and self._check_is_hard_break_route(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.HARD_BREAK_ROUTE_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "HazardAtSideLane" and self._check_scenario_actor_close(
                sample, max_distance=20.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.HAZARD_AT_SIDE_LANE_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "HazardAtSideLaneTwoWays" and self._check_scenario_actor_close(
                sample, max_distance=20.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.HAZARD_AT_SIDE_LANE_TWO_WAYS_SCENARIO].add(route_dir, frame_number)
            elif self._check_highway_cutin_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.HIGHWAY_CUT_IN_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "HighwayExit" and bool(sample["near_urgent_lane_change"]):
                self.buckets[NavsimPretrainSim2RealBuckets.HIGHWAY_EXIT_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "InterurbanActorFlow"
                and len(sample["scenario_actors_ids"]) > 0
                and float(sample["distance_to_next_junction"]) < 5.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.INTERURBAN_ACTOR_FLOW_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "InterurbanAdvancedActorFlow"
                and len(sample["scenario_actors_ids"]) > 0
                and float(sample["distance_to_next_junction"]) < 5.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.INTERURBAN_ADVANCED_ACTOR_FLOW_SCENARIO].add(route_dir, frame_number)
            elif sample["scenario_type"] == "InvadingTurn" and self._check_invading_turn_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.INVADING_TURN_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "MergerIntoSlowTraffic" and bool(sample["near_urgent_lane_change"]):
                self.buckets[NavsimPretrainSim2RealBuckets.MERGER_INTO_SLOW_TRAFFIC_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "MergerIntoSlowTrafficV2" and bool(
                sample["near_urgent_lane_change"]
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.MERGER_INTO_SLOW_TRAFFIC_V2_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "NonSignalizedJunctionLeftTurn"
                and float(sample["distance_to_next_junction"]) < 5.0
                and len(sample["scenario_actors_ids"]) > 0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.NON_SIGNALIZED_JUNCTION_LEFT_TURN_SCENARIO].add(
                    route_dir, frame_number
                )
            elif (
                sample["current_active_scenario_type"] == "NonSignalizedJunctionLeftTurnEnterFlow"
                and float(sample["distance_to_next_junction"]) < 5.0
                and len(sample["scenario_actors_ids"]) > 0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.NON_SIGNALIZED_JUNCTION_LEFT_TURN_ENTER_FLOW_SCENARIO].add(
                    route_dir, frame_number
                )
            elif (
                sample["current_active_scenario_type"] == "NonSignalizedJunctionRightTurn"
                and float(sample["distance_to_next_junction"]) < 5.0
                and len(sample["scenario_actors_ids"]) > 0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.NON_SIGNALIZED_JUNCTION_RIGHT_TURN_SCENARIO].add(
                    route_dir, frame_number
                )
            elif self._check_opposite_vehicle_running_red_light_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.OPPOSITE_VEHICLE_RUNNING_RED_LIGHT_SCENARIO].add(
                    route_dir, frame_number
                )
            elif self._check_opposite_vehicle_taking_priority_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.OPPOSITE_VEHICLE_TAKING_PRIORITY_SCENARIO].add(
                    route_dir, frame_number
                )
            elif sample["scenario_type"] == "ParkedObstacle" and self._check_parked_obstacle_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.PARKED_OBSTACLE_SCENARIO].add(route_dir, frame_number)
            elif sample["scenario_type"] == "ParkedObstacleTwoWays" and self._check_parked_obstacle_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.PARKED_OBSTACLE_TWO_WAYS_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "ParkingCrossingPedestrian" and self._check_scenario_actor_close(
                sample, max_distance=20.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.PARKING_CROSSING_PEDESTRIAN_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "ParkingCutIn" and float(sample["dist_to_cutin_vehicle"]) < 20:
                self.buckets[NavsimPretrainSim2RealBuckets.PARKING_CUT_IN_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "ParkingExit":
                self.buckets[NavsimPretrainSim2RealBuckets.PARKING_EXIT_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "PedestrianCrossing" and len(sample["scenario_actors_ids"]) > 0:
                self.buckets[NavsimPretrainSim2RealBuckets.PEDESTRIAN_CROSSING_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "PriorityAtJunction"
                and float(sample["distance_to_next_junction"]) < 5.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.PRIORITY_AT_JUNCTION_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "RedLightWithoutLeadVehicle" and self._check_red_traffic_light(
                sample
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.RED_LIGHT_WITHOUT_LEAD_VEHICLE_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "SignalizedJunctionLeftTurn"
                and float(sample["distance_to_next_junction"]) < 5.0
                and len(sample["scenario_actors_ids"]) > 0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.SIGNALIZED_JUNCTION_LEFT_TURN_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "SignalizedJunctionLeftTurnEnterFlow"
                and float(sample["distance_to_next_junction"]) < 5.0
                and len(sample["scenario_actors_ids"]) > 0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.SIGNALIZED_JUNCTION_LEFT_TURN_ENTER_FLOW_SCENARIO].add(
                    route_dir, frame_number
                )
            elif (
                sample["current_active_scenario_type"] == "SignalizedJunctionRightTurn"
                and float(sample["distance_to_next_junction"]) < 5.0
                and len(sample["scenario_actors_ids"]) > 0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.SIGNALIZED_JUNCTION_RIGHT_TURN_SCENARIO].add(route_dir, frame_number)
            elif sample["current_active_scenario_type"] == "StaticCutIn" and float(sample["dist_to_cutin_vehicle"]) < 20:
                self.buckets[NavsimPretrainSim2RealBuckets.STATIC_CUT_IN_SCENARIO].add(route_dir, frame_number)
            elif sample["scenario_type"] == "VehicleOpensDoorTwoWays" and self._check_vehicle_opens_door_scenario(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.VEHICLE_OPENS_DOOR_TWO_WAYS_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "VehicleTurningRoute"
                and len(sample["scenario_actors_ids"]) > 0
                and self._check_vehicle_turning_route(sample)
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.VEHICLE_TURNING_ROUTE_SCENARIO].add(route_dir, frame_number)
            elif (
                sample["current_active_scenario_type"] == "VehicleTurningRoutePedestrian"
                and len(sample["scenario_actors_ids"]) > 0
                and self._check_vehicle_turning_route_pedestrian(sample)
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.VEHICLE_TURNING_ROUTE_PEDESTRIAN_SCENARIO].add(
                    route_dir, frame_number
                )

            # Non-scenario-specific mining
            elif self._check_red_overhead_traffic_light(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.RED_OVERHEAD_TRAFFIC_LIGHT].add(route_dir, frame_number)
            elif self._check_red_europe_traffic_light(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.RED_EUROPE_TRAFFIC_LIGHT].add(route_dir, frame_number)
            elif bool(sample["slower_occluded_junction"]) and float(sample["distance_to_next_junction"]) < 5.0:
                self.buckets[NavsimPretrainSim2RealBuckets.OCCLUDED_JUNCTION].add(route_dir, frame_number)
            elif bool(sample["near_urgent_lane_change"]):
                self.buckets[NavsimPretrainSim2RealBuckets.NEAR_URGENT_LANE_CHANGE].add(route_dir, frame_number)
            elif abs(float(sample["privileged_acceleration"])) > 17.5:
                self.buckets[NavsimPretrainSim2RealBuckets.HIGH_ACCELERATION].add(route_dir, frame_number)
            elif self._check_large_lateral_deviation(sample):
                self.buckets[NavsimPretrainSim2RealBuckets.LARGE_LATERAL_DEVIATION].add(route_dir, frame_number)
            elif bool(sample["stop_sign_hazard"]) and float(sample["distance_to_next_junction"]) < 10.0:
                self.buckets[NavsimPretrainSim2RealBuckets.STOP_SIGN_HAZARD].add(route_dir, frame_number)
            elif (
                0.0 < float(sample["distance_to_next_junction"]) < 3.5
                and float(sample["speed"]) > 2.0
                and float(sample["privileged_acceleration"]) > 2.0
            ):
                self.buckets[NavsimPretrainSim2RealBuckets.ENTERING_JUNCTION].add(route_dir, frame_number)
            elif float(sample["distance_to_next_junction"]) < 1.0 and float(sample["speed_limit"]) < 50.0 / 3.6:
                self.buckets[NavsimPretrainSim2RealBuckets.CLOSE_TO_JUNCTION].add(route_dir, frame_number)
            elif sample["target_point"][0] < 0:
                self.buckets[NavsimPretrainSim2RealBuckets.CURRENT_TARGET_POINT_BEHIND_EGO].add(route_dir, frame_number)
            elif bool(sample["vehicle_hazard"]):
                self.buckets[NavsimPretrainSim2RealBuckets.VEHICLE_HAZARD].add(route_dir, frame_number)
            elif self._check_red_traffic_light(sample) and float(sample["distance_to_next_junction"]) < 5.0:
                self.buckets[NavsimPretrainSim2RealBuckets.RED_TRAFFIC_LIGHT].add(route_dir, frame_number)
            elif sample["town"] == "Town15":
                self.buckets[NavsimPretrainSim2RealBuckets.TOWN15].add(route_dir, frame_number)
            elif np.linalg.norm(sample["target_point"]) > 175.0 and abs(sample["target_point"][0]) > 10:
                self.buckets[NavsimPretrainSim2RealBuckets.FAR_TARGET_POINT].add(route_dir, frame_number)
            elif abs(float(sample["privileged_acceleration"])) > 15.0:
                self.buckets[NavsimPretrainSim2RealBuckets.MEDIUM_ACCELERATION].add(route_dir, frame_number)
            elif abs(float(sample["privileged_acceleration"])) > 12.5:
                self.buckets[NavsimPretrainSim2RealBuckets.LOW_ACCELERATION].add(route_dir, frame_number)
            elif sample["route_labels_curvature"] > 0.15 and sample["speed"] > 0.1:
                self.buckets[NavsimPretrainSim2RealBuckets.HIGH_ROUTE_CURVATURE].add(route_dir, frame_number)
            elif sample["route_labels_curvature"] > 0.075 and sample["speed"] > 0.1:
                self.buckets[NavsimPretrainSim2RealBuckets.MEDIUM_ROUTE_CURVATURE].add(route_dir, frame_number)
            else:
                self.buckets[NavsimPretrainSim2RealBuckets.OTHERS].add(route_dir, frame_number)

        self.print_statistic()

    def _check_accident_scenario(self, sample: dict) -> bool:
        """Check if sample has accident obstacle actors positioned beyond -10m and within 30m distance."""
        if float(sample["dist_to_accident_site"]) >= 42:
            return False
        if len(sample["scenario_obstacles_ids"]) == 0:
            return False
        scenario_obstacle_ids = set(sample["scenario_obstacles_ids"])
        for box in sample["boxes"]:
            if box["id"] in scenario_obstacle_ids and box["position"][0] > 0.0:
                return True
        return False

    def _check_blocked_intersection(self, sample: dict) -> bool:
        """Check if sample is in a blocked intersection scenario."""
        if sample["current_active_scenario_type"] != "BlockedIntersection":
            return False
        if len(sample["scenario_obstacles_ids"]) == 0:
            return False
        scenario_actor_id = sample["scenario_obstacles_ids"][0]
        for box in sample["boxes"]:
            if (
                box["class"] == "car"
                and float(box["speed"]) < 0.1
                and box["id"] == scenario_actor_id
                and float(box["distance"]) < 15
            ):
                return True
        return False

    def _check_construction_obstacle_scenario(self, sample: dict) -> bool:
        """Check if sample has construction cones positioned beyond -10m and within 42m distance."""
        if float(sample["dist_to_construction_site"]) >= 42:
            return False
        for box in sample["boxes"]:
            if box.get("type_id") == "static.prop.constructioncone" and box["position"][0] > -10.0:
                return True
        return False

    def _check_scenario_actor_close(self, sample: dict, max_distance: float) -> bool:
        """Check if any scenario actor is within max_distance from ego."""
        if len(sample["scenario_actors_ids"]) == 0:
            return False
        scenario_actor_ids = set(sample["scenario_actors_ids"])
        for box in sample["boxes"]:
            if box["id"] in scenario_actor_ids and float(box["distance"]) < max_distance:
                return True
        return False

    def _check_is_hard_break_route(self, sample: dict) -> bool:
        """Check if sample is in a hard break route scenario."""
        if sample["current_active_scenario_type"] != "HardBreakRoute":
            return False
        if not bool(sample["brake"]) or bool(sample["vehicle_hazard"]):
            return False
        if sample["privileged_acceleration"] < -3.0 or float(sample["speed"]) == 0.0:
            return True
        return False

    def _check_highway_cutin_scenario(self, sample: dict) -> bool:
        """Check if sample is in a highway cut-in scenario."""
        if sample["current_active_scenario_type"] != "HighwayCutIn":
            return False
        if len(sample["scenario_actors_ids"]) == 0:
            return False
        scenario_actor_id = sample["scenario_actors_ids"][0]
        for box in sample["boxes"]:
            if box["class"] == "car" and box["id"] == scenario_actor_id and float(box["distance"]) < 32:
                return True
        return False

    def _check_invading_turn_scenario(self, sample: dict) -> bool:
        """Check if sample is in an invading turn scenario."""
        if sample["scenario_type"] != "InvadingTurn":
            return False
        for box in sample["boxes"]:
            if box.get("type_id") == "static.prop.constructioncone" and 0 < box["position"][0] < 16:
                return True
        return False

    def _check_opposite_vehicle_running_red_light_scenario(self, sample: dict) -> bool:
        """Check if sample is in an opposite vehicle running red light scenario."""
        if sample["current_active_scenario_type"] != "OppositeVehicleRunningRedLight":
            return False
        if len(sample["scenario_actors_ids"]) == 0:
            return False
        scenario_actor_id = sample["scenario_actors_ids"][0]
        for box in sample["boxes"]:
            if box["class"] == "car" and box["id"] == scenario_actor_id and float(box["speed"]) > 0.1:
                return True
        return False

    def _check_opposite_vehicle_taking_priority_scenario(self, sample: dict) -> bool:
        """Check if sample is in an opposite vehicle taking priority scenario."""
        if sample["current_active_scenario_type"] != "OppositeVehicleTakingPriority":
            return False
        if len(sample["scenario_actors_ids"]) == 0:
            return False
        scenario_actor_id = sample["scenario_actors_ids"][0]
        for box in sample["boxes"]:
            if box["class"] == "car" and box["id"] == scenario_actor_id and float(box["speed"]) > 0.1:
                return True
        return False

    def _check_parked_obstacle_scenario(self, sample: dict) -> bool:
        """Check if sample has parked vehicles positioned beyond -8m and within 35m distance."""
        if float(sample["dist_to_parked_obstacle"]) >= 35:
            return False
        for box in sample["boxes"]:
            if box["class"] == "car" and float(box["speed"]) < 0.1 and box["position"][0] > -8.0:
                return True
        return False

    def _check_vehicle_opens_door_scenario(self, sample: dict) -> bool:
        """Check if sample has vehicle opening door within 24m distance and not more than 8m behind."""
        if float(sample["dist_to_vehicle_opens_door"]) >= 24:
            return False
        if len(sample["scenario_obstacles_ids"]) == 0:
            return False
        scenario_obstacle_ids = set(sample["scenario_obstacles_ids"])
        for box in sample["boxes"]:
            if box["id"] in scenario_obstacle_ids and box["position"][0] > -8.0:
                return True
        return False

    def _check_red_traffic_light(self, sample: dict) -> bool:
        """Check if sample has red traffic light affecting ego vehicle while stopped."""
        if not sample["light_hazard"]:
            return False
        if float(sample["speed"]) >= 0.1:
            return False

        boxes = sample["boxes"]
        for box in boxes:
            if box["class"] == "traffic_light" and box["state"] == "Red" and box["affects_ego"]:
                return True
        return False

    def _check_vehicle_turning_route(self, sample: dict) -> bool:
        """Check if sample has vehicle turning route scenario."""
        if sample["current_active_scenario_type"] != "VehicleTurningRoute":
            return False
        if len(sample["scenario_actors_ids"]) == 0:
            return False
        scenario_actor_id = sample["scenario_actors_ids"][0]
        for box in sample["boxes"]:
            if box["id"] == scenario_actor_id and float(box["distance"]) < 15:
                return True
        return False

    def _check_vehicle_turning_route_pedestrian(self, sample: dict) -> bool:
        """Check if sample has vehicle turning route scenario."""
        if sample["current_active_scenario_type"] != "VehicleTurningRoutePedestrian":
            return False
        if len(sample["scenario_actors_ids"]) == 0:
            return False
        scenario_actor_id = sample["scenario_actors_ids"][0]
        for box in sample["boxes"]:
            if box["id"] == scenario_actor_id and float(box["distance"]) < 15:
                return True
        return False

    def _check_red_overhead_traffic_light(self, sample: dict) -> bool:
        """Check if sample has red overhead traffic light affecting ego vehicle while stopped."""
        if not sample["light_hazard"]:
            return False
        if float(sample["speed"]) >= 0.1:
            return False

        boxes = sample["boxes"]
        for box in boxes:
            if (
                box["class"] == "traffic_light"
                and box["state"] == "Red"
                and box["affects_ego"]
                and box["is_over_head_traffic_light"]
            ):
                return True
        return False

    def _check_red_europe_traffic_light(self, sample: dict) -> bool:
        """Check if sample has red Europe traffic light affecting ego vehicle while stopped."""
        if not sample["light_hazard"]:
            return False
        if float(sample["speed"]) >= 0.1:
            return False

        boxes = sample["boxes"]
        for box in boxes:
            if (
                box["class"] == "traffic_light"
                and box["state"] == "Red"
                and box["affects_ego"]
                and box["is_europe_traffic_light"]
            ):
                return True
        return False

    def _check_large_lateral_deviation(self, sample: dict) -> bool:
        """Check if any future position has large lateral deviation."""
        route = sample["route"]
        for point in route[:20]:
            if abs(point[1]) > 6.5:
                return True
        return False

    def cache_file_path(self):
        """Return path for cache file"""
        return os.path.join(
            self.config.bucket_collection_path,
            f"navsim_{self.config.num_way_points_prediction}_{self.config.skip_first}_{self.config.skip_last}_{self.config.waypoints_spacing}.gz",
        )

    def buckets_mixture_per_epoch(self, _):
        """
        Define sampling ratios for each bucket depending on epoch. Current implementation uses fixed ratios across all epochs.
        """
        mixture = {bucket: 1.0 for bucket in range(len(self.buckets))}

        mixture[NavsimPretrainSim2RealBuckets.BAD_WEATHER] = 0.0  # NavSim does not have bad weather samples

        mixture[NavsimPretrainSim2RealBuckets.ENTER_ACTOR_FLOW_SCENARIO] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.ENTER_ACTOR_FLOW_V2_SCENARIO] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.HAZARD_AT_SIDE_LANE_TWO_WAYS_SCENARIO] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.INTERURBAN_ACTOR_FLOW_SCENARIO] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.MERGER_INTO_SLOW_TRAFFIC_SCENARIO] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.MERGER_INTO_SLOW_TRAFFIC_V2_SCENARIO] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.HAZARD_AT_SIDE_LANE_SCENARIO] = 0.0
        mixture[NavsimPretrainSim2RealBuckets.NEAR_URGENT_LANE_CHANGE] = 0.0  # Useless
        mixture[NavsimPretrainSim2RealBuckets.CROSSING_BICYCLE_FLOW_SCENARIO] = 0.0
        mixture[NavsimPretrainSim2RealBuckets.HIGHWAY_CUT_IN_SCENARIO] = 0.0
        mixture[NavsimPretrainSim2RealBuckets.PARKING_EXIT_SCENARIO] = 0.0
        mixture[NavsimPretrainSim2RealBuckets.VEHICLE_TURNING_ROUTE_SCENARIO] = 0.0
        mixture[NavsimPretrainSim2RealBuckets.FAR_TARGET_POINT] = 0.0

        mixture[NavsimPretrainSim2RealBuckets.NON_SIGNALIZED_JUNCTION_LEFT_TURN_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.PARKED_OBSTACLE_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.INVADING_TURN_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.ACCIDENT_SCENARIO] = 1.0
        mixture[NavsimPretrainSim2RealBuckets.CONSTRUCTION_OBSTACLE_SCENARIO] = 1.5
        mixture[NavsimPretrainSim2RealBuckets.RED_OVERHEAD_TRAFFIC_LIGHT] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.CROSS_JUNCTION_DEFECT_TRAFFIC_LIGHT_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.NON_SIGNALIZED_JUNCTION_RIGHT_TURN_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.VEHICLE_TURNING_ROUTE_PEDESTRIAN_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.VEHICLE_OPENS_DOOR_TWO_WAYS_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.ENTERING_JUNCTION] = 4.0
        mixture[NavsimPretrainSim2RealBuckets.MEDIUM_ROUTE_CURVATURE] = 1.0
        mixture[NavsimPretrainSim2RealBuckets.STOP_SIGN_HAZARD] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.PARKING_CUT_IN_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.STATIC_CUT_IN_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.CURRENT_TARGET_POINT_BEHIND_EGO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.RED_LIGHT_WITHOUT_LEAD_VEHICLE_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.SIGNALIZED_JUNCTION_LEFT_TURN_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.SIGNALIZED_JUNCTION_LEFT_TURN_ENTER_FLOW_SCENARIO] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.SIGNALIZED_JUNCTION_RIGHT_TURN_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.VEHICLE_TURNING_ROUTE_PEDESTRIAN_SCENARIO] = 2.5
        mixture[NavsimPretrainSim2RealBuckets.RED_LIGHT_WITHOUT_LEAD_VEHICLE_SCENARIO] = 2.0
        mixture[NavsimPretrainSim2RealBuckets.OPPOSITE_VEHICLE_RUNNING_RED_LIGHT_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.OPPOSITE_VEHICLE_TAKING_PRIORITY_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.PEDESTRIAN_CROSSING_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.PRIORITY_AT_JUNCTION_SCENARIO] = 5.0
        mixture[NavsimPretrainSim2RealBuckets.OCCLUDED_JUNCTION] = 3.0
        mixture[NavsimPretrainSim2RealBuckets.RED_OVERHEAD_TRAFFIC_LIGHT] = 0.5  # A bit awkward with NavSim calibration

        mixture[NavsimPretrainSim2RealBuckets.TOWN15] = 0.6
        mixture[NavsimPretrainSim2RealBuckets.VEHICLE_HAZARD] = 0.2
        mixture[NavsimPretrainSim2RealBuckets.ACCIDENT_TWO_WAYS_SCENARIO] = 0.2
        mixture[NavsimPretrainSim2RealBuckets.CONSTRUCTION_OBSTACLE_TWO_WAYS_SCENARIO] = 0.1
        mixture[NavsimPretrainSim2RealBuckets.CLOSE_TO_JUNCTION] = 1.0

        # Downsample uninteresting samples significantly
        mixture[NavsimPretrainSim2RealBuckets.OTHERS] = 0.1

        return mixture

    def print_statistic(self):
        print("\nBucket Statistics:")
        print("=" * 80)
        for i, bucket in enumerate(self.buckets):
            bucket_name = NavsimPretrainSim2RealBuckets.member_at(i).name
            print(f"Bucket {i:2d} - {bucket_name:60s}: {len(bucket.images):6d} samples")

        print("\n" + "=" * 80)
        print("Sampling Ratios:")
        print("=" * 80)
        for i, ratio in self.buckets_mixture_per_epoch(0).items():
            bucket_name = NavsimPretrainSim2RealBuckets.member_at(i).name
            print(f"Bucket {i:2d} - {bucket_name:60s}: {ratio:.2f} {int(ratio * len(self.buckets[i]))}")


if __name__ == "__main__":
    config = TrainingConfig()
    config.force_rebuild_bucket = True  # To avoid recursion error, set to True for the first time
    config.use_carla_data = True
    config.use_navsim_data = True
    config.LTF = True
    config.use_planning_decoder = False
    collection = NavSimBucketCollection(root=config.carla_data, config=config)
    collection.print_statistic()
    from lead.training.data_loader.carla_dataset import CARLAData

    config.force_rebuild_bucket = False
    dataset = CARLAData(
        root=config.carla_data,
        config=config,
    )
    print(f"Dataset size with subsampling: {len(dataset)} samples")
